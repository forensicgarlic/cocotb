
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
        <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Tutorial: Ping &#8212; cocotb 1.0 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Tutorial: Driver Cosimulation" href="hal_cosimulation.html" />
    <link rel="prev" title="Tutorial: Endian Swapper" href="endian_swapper.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="hal_cosimulation.html" title="Tutorial: Driver Cosimulation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="endian_swapper.html" title="Tutorial: Endian Swapper"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">cocotb 1.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tutorial-ping">
<h1>Tutorial: Ping<a class="headerlink" href="#tutorial-ping" title="Permalink to this headline">¶</a></h1>
<p>One of the benefits of Python is the ease with which interfacing is possible.
In this tutorial we’ll look at interfacing the standard GNU <a class="reference external" href="http://www.gnu.org/software/inetutils/manual/html_node/ping-invocation.html">ping</a> command
to the simulator. Using Python we can ping our DUT with fewer than 50 lines of
code.</p>
<p>For the impatient this tutorial is provided as an example with Cocotb. You can
run this example from a fresh checkout:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">examples</span><span class="o">/</span><span class="n">ping_tun_tap</span><span class="o">/</span><span class="n">tests</span>
<span class="n">sudo</span> <span class="n">make</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To create a virtual interface the test either needs root permissions or have CAP_NET_ADMIN capability.</p>
</div>
<div class="section" id="architecture">
<h2>Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline">¶</a></h2>
<p>We have a simple RTL block that takes ICMP echo requests and generates an ICMP
echo response.  To verify this behaviour we want to run the <a class="reference external" href="http://www.gnu.org/software/inetutils/manual/html_node/ping-invocation.html">ping</a> utility
against our RTL running in the simulator.</p>
<p>In order to achieve this we need to capture the packets that are created by
ping, drive them onto the pins of our DUT in simulation, monitor the output of
the DUT and send any responses back to the ping process.</p>
<p>Linux has a <a class="reference external" href="http://en.wikipedia.org/wiki/TUN/TAP">TUN/TAP</a> virtual network device which we can use for this
purpose, allowing <a class="reference external" href="http://www.gnu.org/software/inetutils/manual/html_node/ping-invocation.html">ping</a> to run unmodified and unaware that it is
communicating with our simulation rather than a remote network endpoint.</p>
<img alt="_images/ping_tun_tap.svg" src="_images/ping_tun_tap.svg" /></div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>First of all we need to work out how to create a virtual interface. Python has
a huge developer base and a quick search of the web reveals a <a class="reference external" href="https://gist.github.com/glacjay/585369">TUN example</a>
that looks like an ideal starting point for our testbench. Using this example
we write a function that will create our virtual interface:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">subprocess</span><span class="o">,</span> <span class="nn">fcntl</span><span class="o">,</span> <span class="nn">struct</span>

<span class="k">def</span> <span class="nf">create_tun</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;tun0&quot;</span><span class="p">,</span> <span class="n">ip</span><span class="o">=</span><span class="s2">&quot;192.168.255.1&quot;</span><span class="p">):</span>
    <span class="n">TUNSETIFF</span> <span class="o">=</span> <span class="mh">0x400454ca</span>
    <span class="n">TUNSETOWNER</span> <span class="o">=</span> <span class="n">TUNSETIFF</span> <span class="o">+</span> <span class="mi">2</span>
    <span class="n">IFF_TUN</span> <span class="o">=</span> <span class="mh">0x0001</span>
    <span class="n">IFF_NO_PI</span> <span class="o">=</span> <span class="mh">0x1000</span>
    <span class="n">tun</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/dev/net/tun&#39;</span><span class="p">,</span> <span class="s1">&#39;r+b&#39;</span><span class="p">)</span>
    <span class="n">ifr</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;16sH&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">IFF_TUN</span> <span class="o">|</span> <span class="n">IFF_NO_PI</span><span class="p">)</span>
    <span class="n">fcntl</span><span class="o">.</span><span class="n">ioctl</span><span class="p">(</span><span class="n">tun</span><span class="p">,</span> <span class="n">TUNSETIFF</span><span class="p">,</span> <span class="n">ifr</span><span class="p">)</span>
    <span class="n">fcntl</span><span class="o">.</span><span class="n">ioctl</span><span class="p">(</span><span class="n">tun</span><span class="p">,</span> <span class="n">TUNSETOWNER</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">subprocess</span><span class="o">.</span><span class="n">check_call</span><span class="p">(</span><span class="s1">&#39;ifconfig tun0 </span><span class="si">%s</span><span class="s1"> up pointopoint 192.168.255.2 up&#39;</span> <span class="o">%</span> <span class="n">ip</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tun</span>
</pre></div>
</div>
<p>Now we can get started on the actual test.  First of all we’ll create a clock
signal and connect up the Avalon driver and monitor to the DUT.  To help debug
the testbench we’ll enable verbose debug on the drivers and monitors by setting
the log level to <strong>logging.DEBUG</strong>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cocotb</span>
<span class="kn">from</span> <span class="nn">cocotb.clock</span> <span class="kn">import</span> <span class="n">Clock</span>
<span class="kn">from</span> <span class="nn">cocotb.drivers.avalon</span> <span class="kn">import</span> <span class="n">AvalonSTPkts</span> <span class="k">as</span> <span class="n">AvalonSTDriver</span>
<span class="kn">from</span> <span class="nn">cocotb.monitors.avalon</span> <span class="kn">import</span> <span class="n">AvalonSTPkts</span> <span class="k">as</span> <span class="n">AvalonSTMonitor</span>

<span class="nd">@cocotb.test</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">tun_tap_example_test</span><span class="p">(</span><span class="n">dut</span><span class="p">):</span>
    <span class="n">cocotb</span><span class="o">.</span><span class="n">fork</span><span class="p">(</span><span class="n">Clock</span><span class="p">(</span><span class="n">dut</span><span class="o">.</span><span class="n">clk</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">())</span>

    <span class="n">stream_in</span>  <span class="o">=</span> <span class="n">AvalonSTDriver</span><span class="p">(</span><span class="n">dut</span><span class="p">,</span> <span class="s2">&quot;stream_in&quot;</span><span class="p">,</span> <span class="n">dut</span><span class="o">.</span><span class="n">clk</span><span class="p">)</span>
    <span class="n">stream_out</span> <span class="o">=</span> <span class="n">AvalonSTMonitor</span><span class="p">(</span><span class="n">dut</span><span class="p">,</span> <span class="s2">&quot;stream_out&quot;</span><span class="p">,</span> <span class="n">dut</span><span class="o">.</span><span class="n">clk</span><span class="p">)</span>

    <span class="c1"># Enable verbose logging on the streaming interfaces</span>
    <span class="n">stream_in</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
    <span class="n">stream_out</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
</pre></div>
</div>
<p>We also need to reset the DUT and drive some default values onto some of the
bus signals.  Note that we’ll need to import the <strong>Timer</strong> and <strong>RisingEdge</strong>
triggers.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Reset the DUT</span>
<span class="n">dut</span><span class="o">.</span><span class="n">_log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Resetting DUT&quot;</span><span class="p">)</span>
<span class="n">dut</span><span class="o">.</span><span class="n">reset_n</span> <span class="o">&lt;=</span> <span class="mi">0</span>
<span class="n">stream_in</span><span class="o">.</span><span class="n">bus</span><span class="o">.</span><span class="n">valid</span> <span class="o">&lt;=</span> <span class="mi">0</span>
<span class="k">yield</span> <span class="n">Timer</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>
<span class="k">yield</span> <span class="n">RisingEdge</span><span class="p">(</span><span class="n">dut</span><span class="o">.</span><span class="n">clk</span><span class="p">)</span>
<span class="n">dut</span><span class="o">.</span><span class="n">reset_n</span> <span class="o">&lt;=</span> <span class="mi">1</span>
<span class="n">dut</span><span class="o">.</span><span class="n">stream_out_ready</span> <span class="o">&lt;=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The rest of the test becomes fairly straightforward.  We create our TUN
interface using our function defined previously.  We’ll also use the
<strong>subprocess</strong> module to actually start the ping command.</p>
<p>We then wait for a packet by calling a blocking read call on the TUN file
descriptor and simply append that to the queue on the driver. We wait for
a packet to arrive on the monitor by yielding on wait_for_recv() and then
write the received packet back to the TUN file descriptor.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create our interface (destroyed at the end of the test)</span>
<span class="n">tun</span> <span class="o">=</span> <span class="n">create_tun</span><span class="p">()</span>
<span class="n">fd</span> <span class="o">=</span> <span class="n">tun</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>

<span class="c1"># Kick off a ping...</span>
<span class="n">subprocess</span><span class="o">.</span><span class="n">check_call</span><span class="p">(</span><span class="s1">&#39;ping -c 5 192.168.255.2 &amp;&#39;</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Respond to 5 pings, then quit</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>

    <span class="n">cocotb</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Waiting for packets on tun interface&quot;</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span>
    <span class="n">cocotb</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Received a packet!&quot;</span><span class="p">)</span>

    <span class="n">stream_in</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">stream_out</span><span class="o">.</span><span class="n">wait_for_recv</span><span class="p">()</span>

    <span class="n">os</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</pre></div>
</div>
<p>That’s it - simple!</p>
</div>
<div class="section" id="further-work">
<h2>Further work<a class="headerlink" href="#further-work" title="Permalink to this headline">¶</a></h2>
<p>This example is deliberately simplistic to focus on the fundamentals of
interfacing to the simulator using TUN/TAP. As an exercise for the reader a
useful addition would be to make the file descriptor non-blocking and spawn
out separate coroutines for the monitor / driver, thus decoupling the sending
and receiving of packets.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Tutorial: Ping</a><ul>
<li><a class="reference internal" href="#architecture">Architecture</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#further-work">Further work</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="endian_swapper.html"
                        title="previous chapter">Tutorial: Endian Swapper</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="hal_cosimulation.html"
                        title="next chapter">Tutorial: Driver Cosimulation</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/ping_tun_tap.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="hal_cosimulation.html" title="Tutorial: Driver Cosimulation"
             >next</a> |</li>
        <li class="right" >
          <a href="endian_swapper.html" title="Tutorial: Endian Swapper"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">cocotb 1.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014, PotentialVentures.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.0.
    </div>
  </body>
</html>